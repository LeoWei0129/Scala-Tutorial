模式匹配match

Scala中的模式匹配類似於Java中的switch語法，但是更加強大

模式匹配語法中，採用match關鍵字聲明，每個分支採用case關鍵字進行聲明，當需要匹配時，會從第一個case分支開始，如果匹配成功，
那麼執行對應的邏輯代碼，如果匹配不成功，繼續執行下一個分支進行判斷，如果所有case都不匹配，那麼會執行case_分支，類似於
Java中的default語句

注意事項
1. 如果都匹配不成功，又沒有寫case _，會拋出MatchError
2. 每個case中，不用break語句，自動中斷case
3. 可以在match中使用其他類型，而不僅僅是字符(但也不是全部類型都可以，ex: 字符串、集合類型都不行)
4. =>等價於Java中的:
5. =>後面的代碼塊到下一個case，是作為一個整體執行，可以使用{}，也可以不使用
6. 可以有多個case _，只是只會匹配第一個case _，其他的case _都不會匹配到，但盡量不要這樣寫
7. case _可以寫在最前面，任何情況都能匹配，而不考慮其他匹配了，但若case _ if(...)又符合條件守衛的匹配方式，後面的
   case也有機會走到，且這種情況下要在最後加case _，才不會拋異常

守衛
如果想要表達匹配某個範圍的數據，就需要在模式匹配中增加"條件守衛"(match-case結合了點的匹配和範圍的匹配)

模式中的變量
如果在case關鍵字後跟變量名，那麼match前表達式的值就會給那個變量，之後在該case對應的代碼塊中可以使用

類型匹配
可以匹配對象的任意類型，這樣做避免了isInstanceOf和asInstanceOf方法

注意事項
1. Map[String, Int]和Map[Int, String]是不同的類型，其他類推
2. 在運行類型匹配時，編譯器會預先檢測是否有可能的匹配，如果沒有則會報錯
about類型匹配...
3. val res = obj match {
       case i: Int => i // 表示將i=obj(其他類推)，然後再判斷類型
   }
4. 如果case _:出現在match中間，表示隱藏變量名，即不會在代碼塊中使用到，而不是表示默認匹配(但還是會進行類型判斷)

匹配數組
1. Array(0)匹配只有一個元素且為0的數組
2. Array(x, y)匹配數組有兩個元素，並將兩個元素賦值為x和y，當然可以依次類推Array(x, y, z)匹配數組有三個元素
3. Array(0, _*)匹配數組已0開始

匹配列表
匹配元組