靜態屬性和靜態方法

Java的靜態概念
public static 返回值類型 方法名(參數列表){...} // 靜態方法
public static 屬性類型 屬姓名 // 靜態屬性

Java中的靜態方法並不是通過對象調用的，而是通過類對象調用的，所以靜態操作並不是面向對象的

Scala中靜態的概念 - 伴生對象
Scala語言是完全面向對象的語言，所以並沒有靜態的操作(即在Scala中沒有靜態的概念)，但是為了能夠和Java語言交互(因為Java中
有靜態的概念)，就產生了一種特殊的對象來模擬類對象，我們稱之為類的伴生對象，這個類的所有靜態內容都可以放置在他的伴生對象
中聲明和調用

小結
1. Scala中伴生對象採用object關鍵字聲明，伴生對象中聲明的全是靜態內容，可以通過伴生對象名稱直接調用
2. 伴生對象對應的類稱之為伴生類，伴生對象的名稱應該和伴生類名一致
3. 伴生對象中的屬性和方法都可以通過伴生對象名(類名)直接調用訪問
4. 從語法角度來講，所謂的伴生對象其實就是類的靜態方法和成員的集合
5. 從技術角度來講，Scala還是沒有生成靜態的內容，只不過是將伴生對象生成了一個新的類，實現屬性和方法的調用
6. 從底層園裡看，伴生對象實現靜態特性是依賴於public static final MODULE$實現的
7. 伴生對象的聲明應該和伴生類的聲明在同一個源碼文件中(如果不在同一個文件中會運行錯誤)，但是如果沒有伴生類，也就沒有所謂
   的伴生對象了，所以放在哪裡就無所謂了
8. 如果class A獨立存在，那麼A就是一個類，如果object A獨立存在，那麼A就是一個靜態性質的對象(即類對象)，在object A中聲
   明的屬性和方法可以通過A.屬性和A.方法來實現調用

伴生對象的apply方法
在伴生對象中定義apply方法，可以實現: 類名(參數)的方式來創建對象實例
(EX): val list = List(1, 2, 3)

伴生對象中可以調用伴生類的私有屬性和私有方法，可以解決在main中無法new伴生類的問題

伴生對象在底層對應Name$.class
伴生類在底層對應Name.class

apply()和unapply()於底層中被定義在Name$.class裡