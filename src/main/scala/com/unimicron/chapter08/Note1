Java、Scala繼承

1. 語法
class 子類名 extends 父類名 {類體}
子類繼承父類的屬性和方法

2. 基本介紹
繼承可以解決代碼複用，讓我們的編程更加考進人類思維，當多個類存在相同的屬性(變量)和方法時，可以從這些類中抽象出
父類，在父類中定義這些相同的屬性和方法，所有的子類不需要重新定義這些屬性和方法，只需要通過extends語句來聲明繼
承父類即可
和Java一樣，Scala也支持類的單繼承

3. 繼承的好處
代碼的複用性提高了
代碼的擴展性和維護性提高了(當我們修改父類時，對應的子類就會繼承相應的方法和屬性)

4. Scala子類繼承了甚麼?甚麼繼承了?
子類繼承了所有屬性，只是私有的屬性不能直接訪問，需要通過公共的方法去訪問

5. 重寫方法
scala明確規定，重寫一個"非抽象方法"需要用override修飾符(面對抽象方法的話叫做實現)，調用父類的方法使用super關鍵字

6. Scala中類型檢查與轉換
要測試某個對象是否屬於某個給定的類，可以用isInstanceOf方法，用asInstanceOf方法將某種引用轉換為子類的引用，classOf
獲取對象的類名
classOf[String]如圖Java的String.class
obj.isInstanceOf[T]如同Java的obj.isInstanceof T，判斷obj是不是T類型
obj.asInstanceOf[T]如同Java的(T)obj，將obj強制轉成T類型
最佳實踐
類型檢查和轉換的最大價值在於，可以判斷傳入對象的類型，然後轉成對應的子類對象，進行相關的操作，這也體現出多態
的特點

7. 超類的構造
在Java中，創毽子類對象時，子類的構造器總是會去調用一個父類的構造器(顯式或隱式調用)，當隱式調用時，會調用super()，
這是無參的父類構造器
在Scala中，只有主構造器可以調用父類的構造器，輔助構造器不能直接調用父類的構造器，無論主或輔助都不能調用，在Scala的輔助構造器中，不能
調用super(params)

8. 覆寫字段
在Scala中，子類改寫父類的字段，稱為覆寫/重寫字段，覆寫字段須使用override修飾
在Java中，只有方法的重寫，沒有屬性/字段的重寫，準確地講，是隱藏字段代替了重寫，在記憶體內，這兩個相同的字段
變量名分別有兩個地址，分別儲存了父類和子類的字段值

9. 覆寫字段注意事項
def只能重寫另一個def(方法只能重寫另一個方法)
val只能重寫另一個val屬性或重寫不帶參數的def
var只能重寫另一個抽象的var屬性

