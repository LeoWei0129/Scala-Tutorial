Scala中trait的使用

一個類具有某種特質(繼承了某個trait)，就意味著這個類滿足了這個特質trait的所有要素，所以在使用時，也採用了extends關鍵字，
如果有多個特質或存在父類，需使用with關鍵字來連接

1. 沒有父類
class 類名 extends 特質1 with 特質2 with 特質3
2. 有父類
class 類名 extends 父類 with 特質1 with 特質2 with 特質3

可以把特質看作是對繼承的一種補充
Scala的繼承是單繼承，也就是一個類最多只能有一個父類，比c++的多繼承機制簡潔，但對子類功能的擴展有一定影響，所以我們認為:
Scala引入trait特質，第一個以替代Java接口，第二個也是對單繼承機制的一種補充

觀念說明
1. Scala提供了特質trait，特質可以同時擁有抽象方法和具體方法，一個類可以實現/繼承多個特質

帶有特質的對象，動態混入mixin
1. 除了可以在類聲明時繼承特質以外，還可以在構建對象時混入特質，擴展目標類的功能
2. 此種方式也可以應用於對抽象類功能進行擴展
3. 動態混入是Scala特有的方式(Java沒有動態混入)，可在不修改類聲明/定義的情況下，擴展類的功能，非常的靈活，耦合性低
   (也就是說，原本是class A，不必寫成class A extends Trait1，只要在構建對象時混入特質就好)
4. 動態混入可以在不影響原有的繼承關係的基礎上，給指定的類擴展功能(不需要此特質功能的子類不會繼承到)
5. 思考: 如果抽象類中有抽象的方法，如何動態混入特質? 先混入特質，再以匿名子類的方式實現抽象方法

在Scala中，有幾種創建對象的方式?
1. new對象
2. apply方式
3. 匿名子類方式
4. 動態混入

疊加特質
1. 構建對象的"同時"如果混入多個特質，稱之為疊加特質，那麼特質聲明順序從左到右，方法執行順序從右到左
2. 在執行疊加對象的方法時，會首先從後面的特質開始執行(從右向左)
3. 特質中如果調用super，並不是表示調用父特質的方法，而是向前面(左邊)的特質繼續查找特質，如果找不到，才會去父特質查找
4. 如果想要調用具體特質的方法，可以指定: super[特質].xxx(...)，其中的泛型必須是該特質的直接超類類型


