創建對象
1. val var 對象名 [: 類型] = new 類型()
2. 如果不希望改變對象的引用(即內存地址)，應聲明為val，否則聲明為var，Scala設計者推薦使用val，因為通常情況
   下，我們改變的是對象屬性的值，而不是改變對象的引用
3. Scala在聲明對象的變量時，可以根據創建對象的類型自動推斷，所以類型聲明可以省略，但當類型和後面的new對象類
   行有繼承關係即多態時，就必須寫了

Constructor
1. Scala構造對象也需要調用構造方法，並且可以有任意多個構造方法，也就是Scala支持重載
2. Scala類的構造器包括: 主構造器、輔助構造器
3. 輔助構造器的名稱是this，可以有多個，編譯器透過參數個數、參數型別來區分這些輔助構造器

Constructor注意事項
1. Scala構造器的作用是完成新對象的初始化，構造器沒有返回值
2. 主構造器的聲明是放置於類名之後
3. 主構造器會執行類定義中的所有語句，這裡可以體會到函數式編程與面向對象編程融合在一起，即構造器也是方法(函數)，
   傳遞參數及使用方法的功能和前面的函數部分內容沒有區別
   *主構造器其實也是一個方法，這個方法作用的範圍是class下的一級語句，也就是類體中除了方法之外的所有語句都包
   進這個主構造器方法中
4. 如果主構造器無參數，小括號可省略，創建對象時調用的構造方法小括號也可以省略
5. 輔助構造器的名稱為this，多個輔助構造器通過不同的參數列表進行區分，在底層就是構造器重載
6. 如果想讓主構造器變成私有的，可在()前加上private，這樣就只能通過輔助構造器構造對象
7. 輔助構造器的聲明不能和主構造器的聲明一致(參數列表一致)，不然報錯，即在底層的構造器名重複了
*參數列表是否一致只關注參數的數量和類型，參數名稱無所謂

Beam屬性
JavaBeans規範定義了Java的屬性有像getXXX()、setXXX()的方法，許多Java工具(框架)都依賴這個命名習慣，為了
Java的互操作性，將Scala屬性加@BeanProperty時，會自動生成規範的getXXX()、setXXX()，這時可以使用
對象.getXXX()和對象.setXXX()
*給某個屬性加入@BeanProperty註釋後，生成的getXXX()、setXXX()和原來底層自動生成的xxx()、xxx_$eq()沒有
衝突，二者可共存